using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ametrin.Serializer.Generator;

[Generator]
public sealed class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Ametrin.Serializer.GenerateSerializerAttribute",
            static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
            static (ctx, cancellationToken) => (INamedTypeSymbol)ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!
        );

        context.RegisterSourceOutput(nodes, static (context, type) =>
        {
            var attribute = type.GetAttribute(IsGenerateSerializerAttribute)!;
            var serializeTypeInformation = attribute.ConstructorArguments[0].Value is true;
            var serializedTypeName = attribute.ConstructorArguments[1].Value as string ?? type.ToString();
            var serializeMembers = type.GetMembers().Where(static member => member.HasAttribute(IsSerializeAttribute)).ToImmutableArray();

            if (serializeMembers.Length is 0)
            {
                return;
            }

            var sb = new StringBuilder();

            sb.AppendLine("""
            using Ametrin.Serializer;

            """);

            if (!type.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {type.ContainingNamespace};");
                sb.AppendLine();
            }

            sb.AppendLine("// This file is auto-generated by Ametrin's SerializerGenerator");
            sb.AppendLine("#nullable enable");

            var nesting = new Stack<INamedTypeSymbol>();
            for (var containingType = type.ContainingType; containingType != null; containingType = containingType.ContainingType)
            {
                nesting.Push(containingType);
            }

            foreach (var containingType in nesting)
            {
                sb.AppendLine($"partial class {containingType.Name}");
                sb.AppendLine("{");
            }
            
            sb.AppendLine($$"""
            partial {{type.TypeKind.ToString().ToLower()}} {{type.Name}} : {{(serializeTypeInformation ? "ITypedAmetrinSerializable" : "IAmetrinSerializable")}}<{{type.Name}}>
            {
                [System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
                private {{type.Name}}({{string.Join(", ", serializeMembers.Select(member => $"{GetMemberType(member)} {member.Name.ToLower()}"))}})
                {
            {{string.Join("\n", serializeMembers.Select(member => $"\t\tthis.{member.Name} = {member.Name.ToLower()};"))}}
                }

                public static void Serialize({{type.Name}} self, IAmetrinWriter writer)
                {
            """);
            if (serializeTypeInformation)
            {
                sb.AppendLine($"\t\twriter.WriteStringProperty(\"$type\", \"{serializedTypeName}\");");
            }
            foreach (var member in serializeMembers)
            {
                var infos = member.GetAttribute(IsSerializeAttribute)!;
                var converter = infos.ConstructorArguments[0].Value as INamedTypeSymbol;
                var memberType = GetMemberType(member);

                sb.AppendLine(memberType switch
                {
                    { } when converter is not null => $"\t\t{converter}.WriteProperty(writer, \"{member.Name}\", self.{member.Name});",
                    { } when memberType.HasAttribute(IsGenerateSerializerAttribute) => $"\t\twriter.WriteObjectProperty(\"{member.Name}\", self.{member.Name}!);",
                    { } when IsTypeSupportedByWriter(memberType) => $"\t\twriter.Write{memberType.Name}Property(\"{member.Name}\", self.{member.Name});",
                    { TypeKind: TypeKind.Enum } => $"\t\twriter.WriteInt32Property(\"{member.Name}\", (int)self.{member.Name});",
                    _ => throw new InvalidOperationException($"Unsupported member type {memberType} ({memberType!.SpecialType}) for serialization"),
                });
            }
            sb.AppendLine($$"""
                }

                public static {{type.Name}} Deserialize(IAmetrinReader reader)
                {
                    return new(
                        {{string.Join(",\n\t\t\t", serializeMembers.Select(member =>
                            {
                                var infos = member.GetAttribute(IsSerializeAttribute)!;
                                var converter = infos.ConstructorArguments[0].Value as INamedTypeSymbol;
                                var memberType = GetMemberType(member);
                                return memberType switch
                                {
                                    { } when converter is not null => $"{converter}.ReadProperty(reader, \"{member.Name}\")",
                                    { } when memberType.HasAttribute(IsGenerateSerializerAttribute) => $"reader.ReadObjectProperty<{memberType.WithNullableAnnotation(NullableAnnotation.None)}>(\"{member.Name}\")",
                                    { } when IsTypeSupportedByWriter(memberType) => $"reader.Read{memberType.Name}Property(\"{member.Name}\")",
                                    { TypeKind: TypeKind.Enum } => $"({memberType}) reader.ReadInt32Property(\"{member.Name}\")",
                                    _ => throw new InvalidOperationException($"Unsupported member type {memberType} for deserialization"),
                                };
                            }))}}
                    );
            """);

            if (!type.InstanceConstructors.Where(static ctor => !ctor.IsImplicitlyDeclared).Any())
            {
                sb.AppendLine($$"""
                }

                public {{type.Name}}() 
                {
                    // type had no constructors. re-adding implicit constructor  
            """);
            }

            if (serializeTypeInformation)
            {
                sb.AppendLine($$"""
                }

                [System.Runtime.CompilerServices.ModuleInitializer]
                internal static void Register()
                {
                    AmetrinSerializer.RegisterSerializer<{{type.Name}}>("{{serializedTypeName}}");
            """);
            }

            sb.AppendLine($$"""
                }
            }
            """);

            foreach (var containingType in nesting)
            {
                sb.AppendLine("}");
            }

            context.AddSource($"{type.ToDisplayString()}.Serializer.g.cs", sb.ToString());
        });
    }


}
