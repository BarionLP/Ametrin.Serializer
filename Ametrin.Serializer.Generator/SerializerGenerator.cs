using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ametrin.Serializer.Generator;

[Generator]
public sealed class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Ametrin.Serializer.GenerateSerializerAttribute",
            static (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
            static (ctx, cancellationToken) => (INamedTypeSymbol)ctx.SemanticModel.GetDeclaredSymbol(ctx.TargetNode, cancellationToken)!
        );

        context.RegisterSourceOutput(nodes, static (context, type) =>
        {
            var attribute = type.GetAttribute(IsGenerateSerializerAttribute)!;
            var serializeTypeInformation = attribute.ConstructorArguments[0].Value is true;
            var serializedTypeName = attribute.ConstructorArguments[1].Value as string ?? type.ToString();
            var allProperties = attribute.ConstructorArguments[2].Value is true;
            var allFields = attribute.ConstructorArguments[3].Value is true;
            var serializeMembers = type.GetMembers().Where(member => (allProperties && member is IPropertySymbol) || (allFields && member is IFieldSymbol) || member.HasAttribute(IsSerializeAttribute))
                .Select(static member =>
                {
                    var attribute = member.GetAttribute(IsSerializeAttribute);
                    return (symbol: member, name: member.Name, nameLower: member.Name.ToLower(), type: GetMemberType(member), converter: attribute?.ConstructorArguments[0].Value as INamedTypeSymbol);
                })
                .Where(member => IsSerializablePropertyType(member.type)).ToImmutableArray();

            if (serializeMembers.Length is 0)
            {
                return;
            }

            var sb = new StringBuilder();

            sb.AppendLine("""
            using Ametrin.Serializer;

            """);

            if (!type.ContainingNamespace.IsGlobalNamespace)
            {
                sb.AppendLine($"namespace {type.ContainingNamespace};");
                sb.AppendLine();
            }

            sb.AppendLine("// This file is auto-generated by Ametrin's SerializerGenerator\n");
            sb.AppendLine("#nullable enable");

            var nesting = new Stack<INamedTypeSymbol>();
            for (var containingType = type.ContainingType; containingType != null; containingType = containingType.ContainingType)
            {
                nesting.Push(containingType);
            }

            foreach (var containingType in nesting)
            {
                sb.AppendLine($"partial class {containingType.Name}");
                sb.AppendLine("{");
            }
            
            sb.AppendLine($$"""
            partial {{type.TypeKind.ToString().ToLower()}} {{type.Name}} : {{(serializeTypeInformation ? "ITypedAmetrinSerializable" : "IAmetrinSerializable")}}<{{type.Name}}>
            {
                [System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
                private {{type.Name}}({{string.Join(", ", serializeMembers.Select(member => $"{member.type} {member.nameLower}"))}})
                {
            {{string.Join("\n", serializeMembers.Select(member => $"\t\tthis.{member.name} = {member.nameLower};"))}}
                }

                public static void Serialize({{type.Name}} self, IAmetrinWriter writer)
                {
            """);
            if (serializeTypeInformation)
            {
                sb.AppendLine($"\t\twriter.WriteStringProperty(\"$type\", \"{serializedTypeName}\");");
            }
            foreach (var member in serializeMembers)
            {
                sb.AppendLine(member switch
                {
                    { converter: not null } => $"\t\t{member.converter}.WriteProperty(writer, \"{member.name}\", self.{member.name});",
                    { } when member.type.HasAttribute(IsGenerateSerializerAttribute) => $"\t\twriter.WriteObjectProperty(\"{member.name}\", self.{member.name}!);",
                    { } when IsTypeSupportedByWriter(member.type) => $"\t\twriter.Write{member.type.Name}Property(\"{member.name}\", self.{member.name});",
                    { type.TypeKind: TypeKind.Enum } => $"\t\twriter.WriteInt32Property(\"{member.name}\", (int)self.{member.name});",
                    _ => throw new InvalidOperationException($"Unsupported member type {member.type} for serialization"),
                });
            }
            sb.AppendLine($$"""
                }

                public static {{type.Name}} Deserialize(IAmetrinReader reader)
                {
                    return new(
                        {{string.Join(",\n\t\t\t", serializeMembers.Select(member =>
                            {
                                return member switch
                                {
                                    { converter: not null } => $"{member.converter}.ReadProperty(reader, \"{member.name}\")",
                                    { } when member.type.HasAttribute(IsGenerateSerializerAttribute) => $"reader.ReadObjectProperty<{member.type.WithNullableAnnotation(NullableAnnotation.None)}>(\"{member.name}\")",
                                    { } when IsTypeSupportedByWriter(member.type) => $"reader.Read{member.type.Name}Property(\"{member.name}\")",
                                    { type.TypeKind: TypeKind.Enum } => $"({member.type}) reader.ReadInt32Property(\"{member.name}\")",
                                    _ => throw new InvalidOperationException($"Unsupported member type {member.type} for deserialization"),
                                };
                            }))}}
                    );
            """);

            if (!type.InstanceConstructors.Where(static ctor => !ctor.IsImplicitlyDeclared).Any())
            {
                sb.AppendLine($$"""
                }

                public {{type.Name}}() 
                {
                    // type had no constructors. re-adding implicit constructor  
            """);
            }

            if (serializeTypeInformation)
            {
                sb.AppendLine($$"""
                }

                [System.Runtime.CompilerServices.ModuleInitializer]
                internal static void Register()
                {
                    AmetrinSerializer.RegisterSerializer<{{type.Name}}>("{{serializedTypeName}}");
            """);
            }

            sb.AppendLine($$"""
                }
            }
            """);

            foreach (var containingType in nesting)
            {
                sb.AppendLine("}");
            }

            context.AddSource($"{type.ToDisplayString()}.Serializer.g.cs", sb.ToString());
        });
    }


}
